diff --git a/README.md b/README.md
index 1f25be01b28cc07e75da1ea2ec8febf9f8fffd64..30e45a7b3da75d0ec2c0393f88458d24fb81f411 100644
--- a/README.md
+++ b/README.md
@@ -5,38 +5,42 @@ This repository contains a small FastAPI application that launches a Jupyter Lab
 The web interface prompts for an email address. When you submit the form it launches a Jupyter Lab server inside a Kubernetes pod and stores the resulting URL for that email. If you request again with the same email, the stored URL is returned instead of creating a new pod.
 
 ## Requirements
 
 - Python 3.10+
 - Access to a Kubernetes cluster with GPU nodes
 - The [Kubernetes Python client](https://github.com/kubernetes-client/python) and `kubectl` configured to access your cluster
 - `pip` to install Python dependencies
 
 Install the dependencies with:
 
 ```bash
 pip install -r requirements.txt
 ```
 
 ## Running
 
 Start the application using uvicorn:
 
 ```bash
 uvicorn app:app --host 0.0.0.0 --port 8000
 ```
 
 Open `http://localhost:8000` in your browser and enter your email address. The application stores the notebook URL and the Kubernetes pod name in a local SQLite database and reuses the information on subsequent requests.
 
+Each time a container is successfully started, the email address and the start
+time are recorded in a separate `logs` table within the same database. This
+table can be used to track container launches over time.
+
 ## Customisation
 
 `container_manager.py` contains the logic for starting the Kubernetes pod. You can modify the image or startup command there if required. The script selects a node that still has available GPUs and schedules the pod on it.
 
 ### Kubernetes Setup
 
 1. Ensure your kubeconfig is accessible (e.g. via `~/.kube/config`).
 2. The nodes must expose the GPU resource as `amd.com/gpu`.
 3. Install the Python dependencies and then start the FastAPI server as described above.
 
 ## License
 
 This project is released under the MIT License.
diff --git a/app.py b/app.py
index 3fb602959f464062ca75dfacf5fa331c811c0e38..e78b343e84a17729493c284153ae958b1e12ca30 100644
--- a/app.py
+++ b/app.py
@@ -2,114 +2,140 @@ from fastapi import FastAPI, Request, BackgroundTasks
 from fastapi.responses import HTMLResponse, JSONResponse
 from fastapi.staticfiles import StaticFiles
 from fastapi.templating import Jinja2Templates
 from container_manager import start_pod_and_get_jupyter_url
 import psycopg2
 import os
 
 DB_HOST = os.environ.get("POSTGRES_HOST", "localhost")
 DB_NAME = os.environ.get("POSTGRES_DB", "flaskdb")
 DB_USER = os.environ.get("POSTGRES_USER", "flaskuser")
 DB_PASSWORD = os.environ.get("POSTGRES_PASSWORD", "flaskpass")
 
 
 def get_conn():
     return psycopg2.connect(
         host=DB_HOST,
         dbname=DB_NAME,
         user=DB_USER,
         password=DB_PASSWORD,
     )
 
 
 def init_db():
     with get_conn() as conn:
         with conn.cursor() as cur:
-            cur.execute("""
+            cur.execute(
+                """
                 DO $$
                 BEGIN
                     IF NOT EXISTS (
                         SELECT 1 FROM information_schema.tables
                         WHERE table_schema = 'public'
                         AND table_name = 'sessions'
                     ) THEN
                         CREATE TABLE sessions (
                             email TEXT PRIMARY KEY,
                             url TEXT,
                             pod_name TEXT
                         );
                     END IF;
+
+                    IF NOT EXISTS (
+                        SELECT 1 FROM information_schema.tables
+                        WHERE table_schema = 'public'
+                        AND table_name = 'logs'
+                    ) THEN
+                        CREATE TABLE logs (
+                            id SERIAL PRIMARY KEY,
+                            email TEXT,
+                            started_at TIMESTAMP
+                        );
+                    END IF;
                 END
                 $$;
-            """)
+                """
+            )
             cur.execute(
                 "ALTER TABLE sessions ADD COLUMN IF NOT EXISTS pod_name TEXT"
             )
         conn.commit()
 
 
 
 app = FastAPI()
 templates = Jinja2Templates(directory="templates")
 app.mount("/static", StaticFiles(directory="static"), name="static")
 init_db()
 
 
 def create_session(email: str):
     with get_conn() as conn:
         with conn.cursor() as cur:
             cur.execute(
                 "INSERT INTO sessions(email, url, pod_name) VALUES (%s, NULL, NULL) ON CONFLICT DO NOTHING",
                 (email,),
             )
         conn.commit()
 
 
 def update_session_url(email: str, url: str, pod_name: str | None):
     with get_conn() as conn:
         with conn.cursor() as cur:
             cur.execute(
                 "UPDATE sessions SET url = %s, pod_name = %s WHERE email = %s",
                 (url, pod_name, email),
             )
         conn.commit()
 
 
 def get_session_url(email: str) -> tuple[str | None, str | None]:
     with get_conn() as conn:
         with conn.cursor() as cur:
             cur.execute(
                 "SELECT url, pod_name FROM sessions WHERE email = %s", (email,)
             )
             row = cur.fetchone()
             return (row[0], row[1]) if row else (None, None)
 
 
+def log_container_start(email: str):
+    """Insert a log entry recording when a container was started."""
+    with get_conn() as conn:
+        with conn.cursor() as cur:
+            cur.execute(
+                "INSERT INTO logs(email, started_at) VALUES (%s, NOW())",
+                (email,),
+            )
+        conn.commit()
+
+
 def launch_container(email: str):
     pod_name, jupyter_url = start_pod_and_get_jupyter_url()
     if jupyter_url:
         update_session_url(email, jupyter_url, pod_name)
+        log_container_start(email)
 
 
 @app.get("/no_gpu", response_class=HTMLResponse)
 async def no_gpu(request: Request):
     return templates.TemplateResponse("gpu_unavailable.html", {"request": request})
 
 
 @app.get("/", response_class=HTMLResponse)
 async def home(request: Request):
     return templates.TemplateResponse("index.html", {"request": request})
 
 
 @app.post("/launch")
 async def launch(background_tasks: BackgroundTasks, request: Request):
     data = await request.json()
     email = data.get("email")
     if not email:
         return JSONResponse({"error": "email required"}, status_code=400)
 
     existing_url, _ = get_session_url(email)
     if existing_url:
         return JSONResponse({"url": existing_url})
 
     create_session(email)
     background_tasks.add_task(launch_container, email)
