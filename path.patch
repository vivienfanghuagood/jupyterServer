diff --git a/README.md b/README.md
index e9cc6a972826d590b2c7ba2d134ac8c56f09dbe5..33f29f08a9fd57a56d416caf0d8c4e461378b2db 100644
--- a/README.md
+++ b/README.md
@@ -1,42 +1,42 @@
 # Jupyter Server Launcher
 
 This repository contains a small FastAPI application that launches a Jupyter Lab server inside a Kubernetes pod.
 
-The web interface provides a single button which starts the pod and shows a progress bar until Jupyter is ready. Once the notebook server is up, the page redirects to the running instance.
+The web interface prompts for an email address. When you submit the form it launches a Jupyter Lab server inside a Kubernetes pod and stores the resulting URL for that email. If you request again with the same email, the stored URL is returned instead of creating a new pod.
 
 ## Requirements
 
 - Python 3.10+
 - Access to a Kubernetes cluster with GPU nodes
 - The [Kubernetes Python client](https://github.com/kubernetes-client/python) and `kubectl` configured to access your cluster
 - `pip` to install Python dependencies
 
 Install the dependencies with:
 
 ```bash
 pip install -r requirements.txt
 ```
 
 ## Running
 
 Start the application using uvicorn:
 
 ```bash
 uvicorn app:app --host 0.0.0.0 --port 8000
 ```
 
-Open `http://localhost:8000` in your browser. The web interface automatically begins launching a notebook pod. Each request is assigned a session ID that is stored in a local SQLite database. The page polls the API with this ID until the Jupyter server is ready and then redirects your browser to the running instance.
+Open `http://localhost:8000` in your browser and enter your email address. The application stores the notebook URL in a local SQLite database and reuses it on subsequent requests.
 
 ## Customisation
 
 `container_manager.py` contains the logic for starting the Kubernetes pod. You can modify the image or startup command there if required. The script selects a node that still has available GPUs and schedules the pod on it.
 
 ### Kubernetes Setup
 
 1. Ensure your kubeconfig is accessible (e.g. via `~/.kube/config`).
 2. The nodes must expose the GPU resource as `amd.com/gpu`.
 3. Install the Python dependencies and then start the FastAPI server as described above.
 
 ## License
 
 This project is released under the MIT License.
diff --git a/app.py b/app.py
index 36a1a8ae53eaa435af7dd1763d558a3bbf3117ac..8ebec9a5be59e287c0f45badc9a37e8cf325728b 100644
--- a/app.py
+++ b/app.py
@@ -1,83 +1,89 @@
 from fastapi import FastAPI, Request, BackgroundTasks
 from fastapi.responses import HTMLResponse, JSONResponse
 from fastapi.staticfiles import StaticFiles
 from fastapi.templating import Jinja2Templates
 from container_manager import start_pod_and_get_jupyter_url
 import sqlite3
-import uuid
-
-
 
 DB_PATH = "sessions.db"
 
 
 def init_db():
     with sqlite3.connect(DB_PATH) as conn:
         conn.execute(
-            "CREATE TABLE IF NOT EXISTS sessions (session_id TEXT PRIMARY KEY, url TEXT)"
+            "CREATE TABLE IF NOT EXISTS sessions (email TEXT PRIMARY KEY, url TEXT)"
         )
 
+
 app = FastAPI()
 templates = Jinja2Templates(directory="templates")
 app.mount("/static", StaticFiles(directory="static"), name="static")
 init_db()
-def create_session(session_id: str):
+
+
+def create_session(email: str):
     with sqlite3.connect(DB_PATH) as conn:
         conn.execute(
-            "INSERT INTO sessions(session_id, url) VALUES (?, NULL)", (session_id,)
+            "INSERT OR IGNORE INTO sessions(email, url) VALUES (?, NULL)", (email,)
         )
 
 
-def update_session_url(session_id: str, url: str):
+def update_session_url(email: str, url: str):
     with sqlite3.connect(DB_PATH) as conn:
         conn.execute(
-            "UPDATE sessions SET url = ? WHERE session_id = ?", (url, session_id)
+            "UPDATE sessions SET url = ? WHERE email = ?", (url, email)
         )
 
 
-def get_session_url(session_id: str) -> str | None:
+def get_session_url(email: str) -> str | None:
     with sqlite3.connect(DB_PATH) as conn:
         cur = conn.execute(
-            "SELECT url FROM sessions WHERE session_id = ?", (session_id,)
+            "SELECT url FROM sessions WHERE email = ?", (email,)
         )
         row = cur.fetchone()
         return row[0] if row else None
 
 
-def launch_container(session_id: str):
+def launch_container(email: str):
     jupyter_url = start_pod_and_get_jupyter_url()
     if jupyter_url:
-        update_session_url(session_id, jupyter_url)
+        update_session_url(email, jupyter_url)
 
 
 @app.get("/no_gpu", response_class=HTMLResponse)
 async def no_gpu(request: Request):
     """Inform the user that no GPUs are currently available."""
     return templates.TemplateResponse("gpu_unavailable.html", {"request": request})
 
 
 @app.get("/", response_class=HTMLResponse)
 async def home(request: Request):
     return templates.TemplateResponse("index.html", {"request": request})
 
 
 @app.post("/launch")
-async def launch(background_tasks: BackgroundTasks):
-    session_id = str(uuid.uuid4())
-    create_session(session_id)
-    background_tasks.add_task(launch_container, session_id)
-    return JSONResponse(
-        {"message": "Pod is launching, please wait...", "session_id": session_id}
-    )
+async def launch(background_tasks: BackgroundTasks, request: Request):
+    data = await request.json()
+    email = data.get("email")
+    if not email:
+        return JSONResponse({"error": "email required"}, status_code=400)
+
+    existing = get_session_url(email)
+    if existing:
+        return JSONResponse({"url": existing})
+
+    create_session(email)
+    background_tasks.add_task(launch_container, email)
+    return JSONResponse({"message": "Pod is launching, please wait...", "email": email})
 
 
 @app.get("/get_url")
-async def get_url(session_id: str | None = None):
-    url = get_session_url(session_id) if session_id else None
+async def get_url(email: str | None = None):
+    url = get_session_url(email) if email else None
     return JSONResponse({"url": url})
 
 
 if __name__ == "__main__":
     import uvicorn
 
     uvicorn.run("app:app", host="0.0.0.0", port=5000, reload=True)
diff --git a/static/css/styles.css b/static/css/styles.css
index 18e0c644d4d18b0d31db96dada0bef3ebf99ed16..1393484dc913d72780272be25313fd351c006007 100644
--- a/static/css/styles.css
+++ b/static/css/styles.css
@@ -1,11 +1,16 @@
 body {
     font-family: Arial, sans-serif;
     text-align: center;
     padding-top: 50px;
 }
 
 button {
     padding: 10px 20px;
     font-size: 16px;
     cursor: pointer;
 }
+
+input[type="email"] {
+    padding: 8px;
+    font-size: 14px;
+}
diff --git a/static/js/script.js b/static/js/script.js
index 87c45513be68d6aba8175598ae208e117ca585a4..00fa7653ce7f9d52552173d2c99285cb50d31621 100644
--- a/static/js/script.js
+++ b/static/js/script.js
@@ -1,66 +1,77 @@
-// Wait for the DOM to be fully parsed, then start the process
+// Wait for the DOM to be fully parsed, then set up the form handler
 document.addEventListener('DOMContentLoaded', () => {
-    startProcess();
-  });
-  
-  function startProcess() {
-      // Disable the start button to prevent multiple clicks
-      const startBtn = document.getElementById("start-btn");
-      if (startBtn) startBtn.disabled = true;
-      
-      // Show the progress bar container
-      const progressContainer = document.getElementById('progress-container');
-      const progressBar = document.getElementById('progress-bar');
-      progressContainer.style.display = 'block';
-      progressBar.style.width = '0%';
-      progressBar.innerText = '0%';
-  
-      // Start the container launch process
-      let sessionId = null;
-      fetch('/launch', { method: 'POST' })
-          .then(response => response.json())
-          .then(data => {
-              console.log(data.message);
-              sessionId = data.session_id;
-              // Start polling for the Jupyter URL and simulate progress
-              pollForUrl();
-              simulateProgress();
-          })
-          .catch(error => console.error('Error:', error));
-  
-      // Simulated progress (increases up to 90%)
-      let progress = 0;
-      let progressInterval;
-      function simulateProgress() {
-          progressInterval = setInterval(() => {
-              if (progress < 90) {
-                  progress += 2; // Increment progress by 2%
-                  progressBar.style.width = progress + '%';
-                  progressBar.innerText = progress + '%';
-              }
-          }, 200);
-      }
-  
-      // Poll for the Jupyter URL every 2000ms
-      function pollForUrl() {
-          if (!sessionId) return;
-          console.log('Polling for Jupyter URL...');
-          fetch(`/get_url?session_id=${sessionId}`, { method: 'GET' })
-              .then(response => response.json())
-              .then(data => {
-                  if (data.url) {
-                      clearInterval(progressInterval);
-                      progressBar.style.width = '100%';
-                      progressBar.innerText = '100%';
-                      // Wait briefly so the user sees the full progress bar before redirecting
-                      setTimeout(() => {
-                          window.location.href = data.url;
-                      }, 500);
-                  } else {
-                      setTimeout(pollForUrl, 2000);
-                  }
-              })
-              .catch(error => console.error('Error:', error));
-      }
-  }
+    const btn = document.getElementById('request-btn');
+    if (btn) btn.addEventListener('click', startProcess);
+});
 
+function startProcess() {
+    const emailInput = document.getElementById('email-input');
+    if (!emailInput || !emailInput.value) return;
+    const email = emailInput.value;
+
+    // Disable the request button to prevent multiple clicks
+    const requestBtn = document.getElementById('request-btn');
+    if (requestBtn) requestBtn.disabled = true;
+
+    // Show the progress bar container
+    const progressContainer = document.getElementById('progress-container');
+    const progressBar = document.getElementById('progress-bar');
+    progressContainer.style.display = 'block';
+    progressBar.style.width = '0%';
+    progressBar.innerText = '0%';
+
+    // Start the container launch process
+    let userEmail = email;
+    fetch('/launch', {
+        method: 'POST',
+        headers: { 'Content-Type': 'application/json' },
+        body: JSON.stringify({ email })
+    })
+        .then(response => response.json())
+        .then(data => {
+            if (data.url) {
+                window.location.href = data.url;
+            } else {
+                console.log(data.message);
+                // Start polling for the Jupyter URL and simulate progress
+                pollForUrl();
+                simulateProgress();
+            }
+        })
+        .catch(error => console.error('Error:', error));
+
+    // Simulated progress (increases up to 90%)
+    let progress = 0;
+    let progressInterval;
+    function simulateProgress() {
+        progressInterval = setInterval(() => {
+            if (progress < 90) {
+                progress += 2; // Increment progress by 2%
+                progressBar.style.width = progress + '%';
+                progressBar.innerText = progress + '%';
+            }
+        }, 200);
+    }
+
+    // Poll for the Jupyter URL every 2000ms
+    function pollForUrl() {
+        if (!userEmail) return;
+        console.log('Polling for Jupyter URL...');
+        fetch(`/get_url?email=${encodeURIComponent(userEmail)}`, { method: 'GET' })
+            .then(response => response.json())
+            .then(data => {
+                if (data.url) {
+                    clearInterval(progressInterval);
+                    progressBar.style.width = '100%';
+                    progressBar.innerText = '100%';
+                    // Wait briefly so the user sees the full progress bar before redirecting
+                    setTimeout(() => {
+                        window.location.href = data.url;
+                    }, 500);
+                } else {
+                    setTimeout(pollForUrl, 2000);
+                }
+            })
+            .catch(error => console.error('Error:', error));
+    }
+}
diff --git a/templates/index.html b/templates/index.html
index 3ea5fe688718a866fdac604c028ce6c86b5d98d9..0fa9ee352fb9237633e6df49d034271592de3660 100644
--- a/templates/index.html
+++ b/templates/index.html
@@ -1,16 +1,20 @@
 <!DOCTYPE html>
 <html lang="en">
 <head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>Jupyter Launcher</title>
   <link rel="stylesheet" href="{{ url_for('static', path='css/styles.css') }}">
   <script src="{{ url_for('static', path='js/script.js') }}" defer></script>
 </head>
 <body>
+  <div id="form-container">
+    <input type="email" id="email-input" placeholder="Enter your email" required>
+    <button id="request-btn">Request Notebook</button>
+  </div>
   <div id="progress-container" style="display: none; margin-top: 20px;">
     <div id="progress-bar" style="width: 0%; height: 25px; background-color: green; text-align: center; color: white;">0%</div>
   </div>
 </body>
 
 </html>

